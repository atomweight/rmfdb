"""empty message

Revision ID: 1a361f614fec
Revises:
Create Date: 2019-01-01 18:17:11.893260

"""
from alembic import op
import sqlalchemy as sa
from sqlalchemy_searchable import sync_trigger
import sqlalchemy_utils


# revision identifiers, used by Alembic.
revision = '1a361f614fec'
down_revision = None
branch_labels = None
depends_on = None


def upgrade():
    conn = op.get_bind()
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('controls',
    sa.Column('id', sqlalchemy_utils.types.uuid.UUIDType(binary=False), nullable=False),
    sa.Column('control_id', sa.Unicode(), nullable=False),
    sa.Column('family', sa.Unicode(), nullable=False),
    sa.Column('family_acronym', sa.Unicode(), nullable=False),
    sa.Column('text', sa.UnicodeText(), nullable=False),
    sa.Column('name', sa.Unicode(), nullable=False),
    sa.Column('guidance', sa.UnicodeText(), nullable=True),
    sa.Column('confidentiality_threshold', sa.Enum('LOW', 'MODERATE', 'HIGH', 'NONE', name='lowmodhigh'), nullable=False),
    sa.Column('integrity_threshold', sa.Enum('LOW', 'MODERATE', 'HIGH', 'NONE', name='lowmodhigh'), nullable=False),
    sa.Column('availability_threshold', sa.Enum('LOW', 'MODERATE', 'HIGH', 'NONE', name='lowmodhigh'), nullable=False),
    sa.Column('created_at', sa.DateTime(), nullable=False),
    sa.Column('updated_at', sa.DateTime(), nullable=True),
    sa.Column('search_vector', sqlalchemy_utils.types.ts_vector.TSVectorType(), nullable=True),
    sa.PrimaryKeyConstraint('id'),
    sa.UniqueConstraint('control_id')
    )
    op.create_table('cves',
    sa.Column('id', sa.Unicode(), nullable=False),
    sa.PrimaryKeyConstraint('id'),
    sa.UniqueConstraint('id')
    )
    op.create_table('rules',
    sa.Column('id', sqlalchemy_utils.types.uuid.UUIDType(binary=False), nullable=False),
    sa.Column('group_id', sa.Unicode(), nullable=False),
    sa.Column('group_title', sa.Unicode(), nullable=False),
    sa.Column('full_rule_id', sa.Unicode(), nullable=False),
    sa.Column('rule_id', sa.Unicode(), nullable=False),
    sa.Column('rule_revision', sa.Integer(), nullable=False),
    sa.Column('rule_severity', sa.Enum('INFORMATIONAL', 'INFO', 'LOW', 'MEDIUM', 'HIGH', name='ruleseverity'), nullable=False),
    sa.Column('rule_title', sa.Unicode(), nullable=False),
    sa.Column('metadata', sa.JSON(), nullable=True),
    sa.Column('check_content', sa.UnicodeText(), nullable=False),
    sa.Column('fix_text', sa.UnicodeText(), nullable=False),
    sa.Column('created_at', sa.DateTime(), nullable=False),
    sa.Column('updated_at', sa.DateTime(), nullable=True),
    sa.Column('search_vector', sqlalchemy_utils.types.ts_vector.TSVectorType(), nullable=True),
    sa.PrimaryKeyConstraint('id'),
    sa.UniqueConstraint('full_rule_id')
    )
    op.create_table('stig_library',
    sa.Column('id', sqlalchemy_utils.types.uuid.UUIDType(binary=False), nullable=False),
    sa.Column('hash', sa.Unicode(length=128), nullable=False),
    sa.Column('date_downloaded', sa.DateTime(), nullable=False),
    sa.PrimaryKeyConstraint('id'),
    sa.UniqueConstraint('hash')
    )
    op.create_table('stigs',
    sa.Column('id', sqlalchemy_utils.types.uuid.UUIDType(binary=False), nullable=False),
    sa.Column('name', sa.Unicode(), nullable=False),
    sa.Column('description', sa.UnicodeText(), nullable=True),
    sa.Column('version', sa.Integer(), nullable=False),
    sa.Column('release', sa.Integer(), nullable=False),
    sa.Column('release_date', sa.DateTime(), nullable=False),
    sa.Column('created_at', sa.DateTime(), nullable=False),
    sa.Column('updated_at', sa.DateTime(), nullable=True),
    sa.Column('search_vector', sqlalchemy_utils.types.ts_vector.TSVectorType(), nullable=True),
    sa.PrimaryKeyConstraint('id'),
    sa.UniqueConstraint('name', 'version', 'release', name='_stig_uc')
    )
    op.create_table('ccis',
    sa.Column('id', sqlalchemy_utils.types.uuid.UUIDType(binary=False), nullable=False),
    sa.Column('cci_id', sa.Unicode(), nullable=False),
    sa.Column('ap_acronym', sa.Unicode(), nullable=True),
    sa.Column('text', sa.UnicodeText(), nullable=True),
    sa.Column('auditor_guidance', sa.UnicodeText(), nullable=True),
    sa.Column('org_guidance', sa.UnicodeText(), nullable=True),
    sa.Column('control_id', sqlalchemy_utils.types.uuid.UUIDType(binary=False), nullable=True),
    sa.Column('created_at', sa.DateTime(), nullable=False),
    sa.Column('updated_at', sa.DateTime(), nullable=True),
    sa.Column('search_vector', sqlalchemy_utils.types.ts_vector.TSVectorType(), nullable=True),
    sa.ForeignKeyConstraint(['control_id'], ['controls.id'], ),
    sa.PrimaryKeyConstraint('id'),
    sa.UniqueConstraint('cci_id')
    )
    op.create_table('cve_rule_mappings',
    sa.Column('rule_id', sqlalchemy_utils.types.uuid.UUIDType(binary=False), nullable=False),
    sa.Column('cve_id', sa.Unicode(), nullable=False),
    sa.ForeignKeyConstraint(['cve_id'], ['cves.id'], ),
    sa.ForeignKeyConstraint(['rule_id'], ['rules.id'], ),
    sa.UniqueConstraint('rule_id', 'cve_id', name='_rule_cve_uc')
    )
    op.create_table('stig_rule_mappings',
    sa.Column('rule_id', sqlalchemy_utils.types.uuid.UUIDType(binary=False), nullable=False),
    sa.Column('stig_id', sqlalchemy_utils.types.uuid.UUIDType(binary=False), nullable=False),
    sa.ForeignKeyConstraint(['rule_id'], ['rules.id'], ),
    sa.ForeignKeyConstraint(['stig_id'], ['stigs.id'], ),
    sa.UniqueConstraint('rule_id', 'stig_id', name='_rule_stig_uc')
    )
    op.create_table('cci_rule_mappings',
    sa.Column('rule_id', sqlalchemy_utils.types.uuid.UUIDType(binary=False), nullable=False),
    sa.Column('cci_id', sqlalchemy_utils.types.uuid.UUIDType(binary=False), nullable=False),
    sa.ForeignKeyConstraint(['cci_id'], ['ccis.id'], ),
    sa.ForeignKeyConstraint(['rule_id'], ['rules.id'], ),
    sa.UniqueConstraint('rule_id', 'cci_id', name='_rule_cci_uc')
    )
    # ### end Alembic commands ###
    op.execute("""
DROP TYPE IF EXISTS tsq_state CASCADE;

CREATE TYPE tsq_state AS (
    search_query text,
    parentheses_stack int,
    skip_for int,
    current_token text,
    current_index int,
    current_char text,
    previous_char text,
    tokens text[]
);

CREATE OR REPLACE FUNCTION tsq_append_current_token(state tsq_state)
RETURNS tsq_state AS $$
BEGIN
    IF state.current_token != '' THEN
        state.tokens := array_append(state.tokens, state.current_token);
        state.current_token := '';
    END IF;
    RETURN state;
END;
$$ LANGUAGE plpgsql IMMUTABLE;


CREATE OR REPLACE FUNCTION tsq_tokenize_character(state tsq_state)
RETURNS tsq_state AS $$
BEGIN
    IF state.current_char = '(' THEN
        state.tokens := array_append(state.tokens, '(');
        state.parentheses_stack := state.parentheses_stack + 1;
        state := tsq_append_current_token(state);
    ELSIF state.current_char = ')' THEN
        IF (state.parentheses_stack > 0 AND state.current_token != '') THEN
            state := tsq_append_current_token(state);
            state.tokens := array_append(state.tokens, ')');
            state.parentheses_stack := state.parentheses_stack - 1;
        END IF;
    ELSIF state.current_char = '"' THEN
        state.skip_for := position('"' IN substring(
            state.search_query FROM state.current_index + 1
        ));

        IF state.skip_for > 1 THEN
            state.tokens = array_append(
                state.tokens,
                substring(
                    state.search_query
                    FROM state.current_index FOR state.skip_for + 1
                )
            );
        ELSIF state.skip_for = 0 THEN
            state.current_token := state.current_token || state.current_char;
        END IF;
    ELSIF (
        state.current_char = '-' AND
        (state.current_index = 1 OR state.previous_char = ' ')
    ) THEN
        state.tokens := array_append(state.tokens, '-');
    ELSIF state.current_char = ' ' THEN
        state := tsq_append_current_token(state);
        IF substring(
            state.search_query FROM state.current_index FOR 4
        ) = ' or ' THEN
            state.skip_for := 2;

            -- remove duplicate OR tokens
            IF state.tokens[array_length(state.tokens, 1)] != ' | ' THEN
                state.tokens := array_append(state.tokens, ' | ');
            END IF;
        END IF;
    ELSE
        state.current_token = state.current_token || state.current_char;
    END IF;
    RETURN state;
END;
$$ LANGUAGE plpgsql IMMUTABLE;


CREATE OR REPLACE FUNCTION tsq_tokenize(search_query text) RETURNS text[] AS $$
DECLARE
    state tsq_state;
BEGIN
    SELECT
        search_query::text AS search_query,
        0::int AS parentheses_stack,
        0 AS skip_for,
        ''::text AS current_token,
        0 AS current_index,
        ''::text AS current_char,
        ''::text AS previous_char,
        '{}'::text[] AS tokens
    INTO state;

    state.search_query := lower(trim(
        regexp_replace(search_query, '""+', '""', 'g')
    ));

    FOR state.current_index IN (
        SELECT generate_series(1, length(state.search_query))
    ) LOOP
        state.current_char := substring(
            search_query FROM state.current_index FOR 1
        );

        IF state.skip_for > 0 THEN
            state.skip_for := state.skip_for - 1;
            CONTINUE;
        END IF;

        state := tsq_tokenize_character(state);
        state.previous_char := state.current_char;
    END LOOP;
    state := tsq_append_current_token(state);

    state.tokens := array_nremove(state.tokens, '(', -state.parentheses_stack);

    RETURN state.tokens;
END;
$$ LANGUAGE plpgsql IMMUTABLE;


-- Processes an array of text search tokens and returns a tsquery
CREATE OR REPLACE FUNCTION tsq_process_tokens(config regconfig, tokens text[])
RETURNS tsquery AS $$
DECLARE
    result_query text;
    previous_value text;
    value text;
BEGIN
    result_query := '';
    FOREACH value IN ARRAY tokens LOOP
        IF value = '"' THEN
            CONTINUE;
        END IF;

        IF left(value, 1) = '"' AND right(value, 1) = '"' THEN
            value := phraseto_tsquery(config, value);
        ELSIF value NOT IN ('(', ' | ', ')', '-') THEN
            value := quote_literal(value) || ':*';
        END IF;

        IF previous_value = '-' THEN
            IF value = '(' THEN
                value := '!' || value;
            ELSE
                value := '!(' || value || ')';
            END IF;
        END IF;

        SELECT
            CASE
                WHEN result_query = '' THEN value
                WHEN (
                    previous_value IN ('!(', '(', ' | ') OR
                    value IN (')', ' | ')
                ) THEN result_query || value
                ELSE result_query || ' & ' || value
            END
        INTO result_query;
        previous_value := value;
    END LOOP;

    RETURN to_tsquery(config, result_query);
END;
$$ LANGUAGE plpgsql IMMUTABLE;


CREATE OR REPLACE FUNCTION tsq_process_tokens(tokens text[])
RETURNS tsquery AS $$
    SELECT tsq_process_tokens(get_current_ts_config(), tokens);
$$ LANGUAGE SQL IMMUTABLE;


CREATE OR REPLACE FUNCTION tsq_parse(config regconfig, search_query text)
RETURNS tsquery AS $$
    SELECT tsq_process_tokens(config, tsq_tokenize(search_query));
$$ LANGUAGE SQL IMMUTABLE;


CREATE OR REPLACE FUNCTION tsq_parse(config text, search_query text)
RETURNS tsquery AS $$
    SELECT tsq_parse(config::regconfig, search_query);
$$ LANGUAGE SQL IMMUTABLE;


CREATE OR REPLACE FUNCTION tsq_parse(search_query text) RETURNS tsquery AS $$
    SELECT tsq_parse(get_current_ts_config(), search_query);
$$ LANGUAGE SQL IMMUTABLE;


-- remove first N elements equal to the given value from the array (array
-- must be one-dimensional)
--
-- If negative value is given as the third argument the removal of elements
-- starts from the last array element.
CREATE OR REPLACE FUNCTION array_nremove(anyarray, anyelement, int)
RETURNS ANYARRAY AS $$
    WITH replaced_positions AS (
        SELECT UNNEST(
            CASE
            WHEN $2 IS NULL THEN
                '{}'::int[]
            WHEN $3 > 0 THEN
                (array_positions($1, $2))[1:$3]
            WHEN $3 < 0 THEN
                (array_positions($1, $2))[
                    (cardinality(array_positions($1, $2)) + $3 + 1):
                ]
            ELSE
                '{}'::int[]
            END
        ) AS position
    )
    SELECT COALESCE((
        SELECT array_agg(value)
        FROM unnest($1) WITH ORDINALITY AS t(value, index)
        WHERE index NOT IN (SELECT position FROM replaced_positions)
    ), $1[1:0]);
$$ LANGUAGE SQL IMMUTABLE;
    """)
    sync_trigger(
        conn,
        'controls',
        'search_vector',
        [
            'control_id',
            'family',
            'family_acronym',
            'text',
            'name',
            'guidance',
        ]
    )
    sync_trigger(
        conn,
        'stigs',
        'search_vector',
        [
            'name',
            'description',
        ]
    )
    sync_trigger(
        conn,
        'rules',
        'search_vector',
        [
            'group_id',
            'group_title',
            'full_rule_id',
            'rule_title',
            'check_content',
            'fix_text',
        ]
    )
    sync_trigger(
        conn,
        'ccis',
        'search_vector',
        [
            'cci_id',
            'ap_acronym',
            'text',
            'auditor_guidance',
            'org_guidance',
        ]
    )


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_table('cci_rule_mappings')
    op.drop_table('stig_rule_mappings')
    op.drop_table('cve_rule_mappings')
    op.drop_table('ccis')
    op.drop_table('stigs')
    op.drop_table('stig_library')
    op.drop_table('rules')
    op.drop_table('cves')
    op.drop_table('controls')
    # ### end Alembic commands ###
